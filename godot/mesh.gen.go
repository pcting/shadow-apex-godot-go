package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// MeshArrayFormat is an enum for ArrayFormat values.
type MeshArrayFormat int

const (
	MeshArrayCompressBase      MeshArrayFormat = 9
	MeshArrayCompressBones     MeshArrayFormat = 32768
	MeshArrayCompressColor     MeshArrayFormat = 4096
	MeshArrayCompressDefault   MeshArrayFormat = 97280
	MeshArrayCompressIndex     MeshArrayFormat = 131072
	MeshArrayCompressNormal    MeshArrayFormat = 1024
	MeshArrayCompressTangent   MeshArrayFormat = 2048
	MeshArrayCompressTexUv     MeshArrayFormat = 8192
	MeshArrayCompressTexUv2    MeshArrayFormat = 16384
	MeshArrayCompressVertex    MeshArrayFormat = 512
	MeshArrayCompressWeights   MeshArrayFormat = 65536
	MeshArrayFlagUse16BitBones MeshArrayFormat = 524288
	MeshArrayFlagUse2DVertices MeshArrayFormat = 262144
	MeshArrayFormatBones       MeshArrayFormat = 64
	MeshArrayFormatColor       MeshArrayFormat = 8
	MeshArrayFormatIndex       MeshArrayFormat = 256
	MeshArrayFormatNormal      MeshArrayFormat = 2
	MeshArrayFormatTangent     MeshArrayFormat = 4
	MeshArrayFormatTexUv       MeshArrayFormat = 16
	MeshArrayFormatTexUv2      MeshArrayFormat = 32
	MeshArrayFormatVertex      MeshArrayFormat = 1
	MeshArrayFormatWeights     MeshArrayFormat = 128
)

// MeshArrayType is an enum for ArrayType values.
type MeshArrayType int

const (
	MeshArrayBones   MeshArrayType = 6
	MeshArrayColor   MeshArrayType = 3
	MeshArrayIndex   MeshArrayType = 8
	MeshArrayMax     MeshArrayType = 9
	MeshArrayNormal  MeshArrayType = 1
	MeshArrayTangent MeshArrayType = 2
	MeshArrayTexUv   MeshArrayType = 4
	MeshArrayTexUv2  MeshArrayType = 5
	MeshArrayVertex  MeshArrayType = 0
	MeshArrayWeights MeshArrayType = 7
)

// MeshBlendShapeMode is an enum for BlendShapeMode values.
type MeshBlendShapeMode int

const (
	MeshBlendShapeModeNormalized MeshBlendShapeMode = 0
	MeshBlendShapeModeRelative   MeshBlendShapeMode = 1
)

// MeshPrimitiveType is an enum for PrimitiveType values.
type MeshPrimitiveType int

const (
	MeshPrimitiveLines         MeshPrimitiveType = 1
	MeshPrimitiveLineLoop      MeshPrimitiveType = 3
	MeshPrimitiveLineStrip     MeshPrimitiveType = 2
	MeshPrimitivePoints        MeshPrimitiveType = 0
	MeshPrimitiveTriangles     MeshPrimitiveType = 4
	MeshPrimitiveTriangleFan   MeshPrimitiveType = 6
	MeshPrimitiveTriangleStrip MeshPrimitiveType = 5
)

//func NewMeshFromPointer(ptr gdnative.Pointer) Mesh {
func newMeshFromPointer(ptr gdnative.Pointer) Mesh {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Mesh{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Mesh is a type of [Resource] that contains vertex array-based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
	owner gdnative.Object
}

func (o *Mesh) BaseClass() string {
	return "Mesh"
}

/*
        Calculate a [ConvexPolygonShape] from the mesh.
	Args: [], Returns: Shape
*/
func (o *Mesh) CreateConvexShape() ShapeImplementer {
	//log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_convex_shape")

	// Call the parent method.
	// Shape
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newShapeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ShapeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Shape" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ShapeImplementer)
	}

	return &ret
}

/*
        Calculate an outline mesh at a defined offset (margin) from the original mesh. [b]Note:[/b] This method typically returns the vertices in reverse order (e.g. clockwise to counterclockwise).
	Args: [{ false margin float}], Returns: Mesh
*/
func (o *Mesh) CreateOutline(margin gdnative.Real) MeshImplementer {
	//log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_outline")

	// Call the parent method.
	// Mesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Mesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MeshImplementer)
	}

	return &ret
}

/*
        Calculate a [ConcavePolygonShape] from the mesh.
	Args: [], Returns: Shape
*/
func (o *Mesh) CreateTrimeshShape() ShapeImplementer {
	//log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "create_trimesh_shape")

	// Call the parent method.
	// Shape
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newShapeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ShapeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Shape" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ShapeImplementer)
	}

	return &ret
}

/*
        Generate a [TriangleMesh] from the mesh.
	Args: [], Returns: TriangleMesh
*/
func (o *Mesh) GenerateTriangleMesh() TriangleMeshImplementer {
	//log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "generate_triangle_mesh")

	// Call the parent method.
	// TriangleMesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTriangleMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TriangleMeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "TriangleMesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TriangleMeshImplementer)
	}

	return &ret
}

/*
        Returns the smallest [AABB] enclosing this mesh. Not affected by [code]custom_aabb[/code]. [b]Note:[/b] This is only implemented for [ArrayMesh] and [PrimitiveMesh].
	Args: [], Returns: AABB
*/
func (o *Mesh) GetAabb() gdnative.Aabb {
	//log.Println("Calling Mesh.GetAabb()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_aabb")

	// Call the parent method.
	// AABB
	retPtr := gdnative.NewEmptyAabb()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewAabbFromPointer(retPtr)
	return ret
}

/*
        Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
	Args: [], Returns: PoolVector3Array
*/
func (o *Mesh) GetFaces() gdnative.PoolVector3Array {
	//log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_faces")

	// Call the parent method.
	// PoolVector3Array
	retPtr := gdnative.NewEmptyPoolVector3Array()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolVector3ArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Mesh) GetLightmapSizeHint() gdnative.Vector2 {
	//log.Println("Calling Mesh.GetLightmapSizeHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_lightmap_size_hint")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the amount of surfaces that the [Mesh] holds.
	Args: [], Returns: int
*/
func (o *Mesh) GetSurfaceCount() gdnative.Int {
	//log.Println("Calling Mesh.GetSurfaceCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "get_surface_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Mesh) SetLightmapSizeHint(size gdnative.Vector2) {
	//log.Println("Calling Mesh.SetLightmapSizeHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "set_lightmap_size_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the arrays for the vertices, normals, uvs, etc. that make up the requested surface (see [method ArrayMesh.add_surface_from_arrays]).
	Args: [{ false surf_idx int}], Returns: Array
*/
func (o *Mesh) SurfaceGetArrays(surfIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Mesh.SurfaceGetArrays()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_arrays")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the blend shape arrays for the requested surface.
	Args: [{ false surf_idx int}], Returns: Array
*/
func (o *Mesh) SurfaceGetBlendShapeArrays(surfIdx gdnative.Int) gdnative.Array {
	//log.Println("Calling Mesh.SurfaceGetBlendShapeArrays()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_blend_shape_arrays")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Returns a [Material] in a given surface. Surface is rendered using this material.
	Args: [{ false surf_idx int}], Returns: Material
*/
func (o *Mesh) SurfaceGetMaterial(surfIdx gdnative.Int) MaterialImplementer {
	//log.Println("Calling Mesh.SurfaceGetMaterial()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_get_material")

	// Call the parent method.
	// Material
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMaterialFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MaterialImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Material" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MaterialImplementer)
	}

	return &ret
}

/*
        Sets a [Material] for a given surface. Surface will be rendered using this material.
	Args: [{ false surf_idx int} { false material Material}], Returns: void
*/
func (o *Mesh) SurfaceSetMaterial(surfIdx gdnative.Int, material MaterialImplementer) {
	//log.Println("Calling Mesh.SurfaceSetMaterial()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(surfIdx)
	ptrArguments[1] = gdnative.NewPointerFromObject(material.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Mesh", "surface_set_material")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// MeshImplementer is an interface that implements the methods
// of the Mesh class.
type MeshImplementer interface {
	ResourceImplementer
	CreateConvexShape() ShapeImplementer
	CreateOutline(margin gdnative.Real) MeshImplementer
	CreateTrimeshShape() ShapeImplementer
	GenerateTriangleMesh() TriangleMeshImplementer
	GetAabb() gdnative.Aabb
	GetFaces() gdnative.PoolVector3Array
	GetLightmapSizeHint() gdnative.Vector2
	GetSurfaceCount() gdnative.Int
	SetLightmapSizeHint(size gdnative.Vector2)
	SurfaceGetArrays(surfIdx gdnative.Int) gdnative.Array
	SurfaceGetBlendShapeArrays(surfIdx gdnative.Int) gdnative.Array
	SurfaceGetMaterial(surfIdx gdnative.Int) MaterialImplementer
	SurfaceSetMaterial(surfIdx gdnative.Int, material MaterialImplementer)
}
