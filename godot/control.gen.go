package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// ControlAnchor is an enum for Anchor values.
type ControlAnchor int

const (
	ControlAnchorBegin ControlAnchor = 0
	ControlAnchorEnd   ControlAnchor = 1
)

// ControlCursorShape is an enum for CursorShape values.
type ControlCursorShape int

const (
	ControlCursorArrow        ControlCursorShape = 0
	ControlCursorBdiagsize    ControlCursorShape = 11
	ControlCursorBusy         ControlCursorShape = 5
	ControlCursorCanDrop      ControlCursorShape = 7
	ControlCursorCross        ControlCursorShape = 3
	ControlCursorDrag         ControlCursorShape = 6
	ControlCursorFdiagsize    ControlCursorShape = 12
	ControlCursorForbidden    ControlCursorShape = 8
	ControlCursorHelp         ControlCursorShape = 16
	ControlCursorHsize        ControlCursorShape = 10
	ControlCursorHsplit       ControlCursorShape = 15
	ControlCursorIbeam        ControlCursorShape = 1
	ControlCursorMove         ControlCursorShape = 13
	ControlCursorPointingHand ControlCursorShape = 2
	ControlCursorVsize        ControlCursorShape = 9
	ControlCursorVsplit       ControlCursorShape = 14
	ControlCursorWait         ControlCursorShape = 4
)

// ControlFocusMode is an enum for FocusMode values.
type ControlFocusMode int

const (
	ControlFocusAll   ControlFocusMode = 2
	ControlFocusClick ControlFocusMode = 1
	ControlFocusNone  ControlFocusMode = 0
)

// ControlGrowDirection is an enum for GrowDirection values.
type ControlGrowDirection int

const (
	ControlGrowDirectionBegin ControlGrowDirection = 0
	ControlGrowDirectionBoth  ControlGrowDirection = 2
	ControlGrowDirectionEnd   ControlGrowDirection = 1
)

// ControlLayoutPreset is an enum for LayoutPreset values.
type ControlLayoutPreset int

const (
	ControlPresetBottomLeft   ControlLayoutPreset = 2
	ControlPresetBottomRight  ControlLayoutPreset = 3
	ControlPresetBottomWide   ControlLayoutPreset = 12
	ControlPresetCenter       ControlLayoutPreset = 8
	ControlPresetCenterBottom ControlLayoutPreset = 7
	ControlPresetCenterLeft   ControlLayoutPreset = 4
	ControlPresetCenterRight  ControlLayoutPreset = 6
	ControlPresetCenterTop    ControlLayoutPreset = 5
	ControlPresetHcenterWide  ControlLayoutPreset = 14
	ControlPresetLeftWide     ControlLayoutPreset = 9
	ControlPresetRightWide    ControlLayoutPreset = 11
	ControlPresetTopLeft      ControlLayoutPreset = 0
	ControlPresetTopRight     ControlLayoutPreset = 1
	ControlPresetTopWide      ControlLayoutPreset = 10
	ControlPresetVcenterWide  ControlLayoutPreset = 13
	ControlPresetWide         ControlLayoutPreset = 15
)

// ControlLayoutPresetMode is an enum for LayoutPresetMode values.
type ControlLayoutPresetMode int

const (
	ControlPresetModeKeepHeight ControlLayoutPresetMode = 2
	ControlPresetModeKeepSize   ControlLayoutPresetMode = 3
	ControlPresetModeKeepWidth  ControlLayoutPresetMode = 1
	ControlPresetModeMinsize    ControlLayoutPresetMode = 0
)

// ControlMouseFilter is an enum for MouseFilter values.
type ControlMouseFilter int

const (
	ControlMouseFilterIgnore ControlMouseFilter = 2
	ControlMouseFilterPass   ControlMouseFilter = 1
	ControlMouseFilterStop   ControlMouseFilter = 0
)

// ControlSizeFlags is an enum for SizeFlags values.
type ControlSizeFlags int

const (
	ControlSizeExpand       ControlSizeFlags = 2
	ControlSizeExpandFill   ControlSizeFlags = 3
	ControlSizeFill         ControlSizeFlags = 1
	ControlSizeShrinkCenter ControlSizeFlags = 4
	ControlSizeShrinkEnd    ControlSizeFlags = 8
)

//func NewControlFromPointer(ptr gdnative.Pointer) Control {
func newControlFromPointer(ptr gdnative.Pointer) Control {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Control{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Base class for all UI-related nodes. [Control] features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [Control] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [Control] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the focus, call [method grab_focus]. [Control] nodes lose focus when another node grabs it, or if you hide the node in focus. Sets [member mouse_filter] to [constant MOUSE_FILTER_IGNORE] to tell a [Control] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [Control] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	CanvasItem
	owner gdnative.Object
}

func (o *Control) BaseClass() string {
	return "Control"
}

/*
        Virtual method to be implemented by the user. Returns whether [method _gui_input] should not be called for children controls outside this control's rectangle. Input will be clipped to the Rect of this [Control]. Similar to [member rect_clip_content], but doesn't affect visibility. If not overridden, defaults to [code]false[/code].
	Args: [], Returns: bool
*/
func (o *Control) X_ClipsInput() gdnative.Bool {
	//log.Println("Calling Control.X_ClipsInput()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_clips_input")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to [member rect_min_size] for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately). If not overridden, defaults to [constant Vector2.ZERO].
	Args: [], Returns: Vector2
*/
func (o *Control) X_GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: String
*/
func (o *Control) X_GetTooltip() gdnative.String {
	//log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Virtual method to be implemented by the user. Use this method to process and accept inputs on UI elements. See [method accept_event]. Example: clicking a control. [codeblock] func _gui_input(event): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT and event.pressed: print("I've been clicked D:") [/codeblock] The event won't trigger if: * clicking outside the control (see [method has_point]); * control has [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE]; * control is obstructed by another [Control] on top of it, which doesn't have [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE]; * control's parent has [member mouse_filter] set to [constant MOUSE_FILTER_STOP] or has accepted the event; * it happens outside parent's rectangle and the parent has either [member rect_clip_content] or [method _clips_input] enabled.
	Args: [{ false event InputEvent}], Returns: void
*/
func (o *Control) X_GuiInput(event InputEventImplementer) {
	//log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(event.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_gui_input")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Virtual method to be implemented by the user. Returns a [Control] node that should be used as a tooltip instead of the default one. Use [code]for_text[/code] parameter to determine what text the tooltip should contain (likely the contents of [member hint_tooltip]). The returned node must be of type [Control] or Control-derieved. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance, not e.g. a node from scene. When [code]null[/code] or non-Control node is returned, the default tooltip will be used instead. [b]Note:[/b] The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its [member rect_min_size] to some non-zero value. Example of usage with custom-constructed node: [codeblock] func _make_custom_tooltip(for_text): var label = Label.new() label.text = for_text return label [/codeblock] Example of usage with custom scene instance: [codeblock] func _make_custom_tooltip(for_text): var tooltip = preload("SomeTooltipScene.tscn").instance() tooltip.get_node("Label").text = for_text return tooltip [/codeblock]
	Args: [{ false for_text String}], Returns: Object
*/
func (o *Control) X_MakeCustomTooltip(forText gdnative.String) ObjectImplementer {
	//log.Println("Calling Control.X_MakeCustomTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(forText)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_make_custom_tooltip")

	// Call the parent method.
	// Object
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newObjectFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ObjectImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Object" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ObjectImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_OverrideChanged() {
	//log.Println("Calling Control.X_OverrideChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_override_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin int} { false anchor float}], Returns: void
*/
func (o *Control) X_SetAnchor(margin gdnative.Int, anchor gdnative.Real) {
	//log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) X_SetGlobalPosition(position gdnative.Vector2) {
	//log.Println("Calling Control.X_SetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_global_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false margin Vector2}], Returns: void
*/
func (o *Control) X_SetPosition(margin gdnative.Vector2) {
	//log.Println("Calling Control.X_SetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) X_SetSize(size gdnative.Vector2) {
	//log.Println("Calling Control.X_SetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_set_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_SizeChanged() {
	//log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_ThemeChanged() {
	//log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_theme_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *Control) X_UpdateMinimumSize() {
	//log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "_update_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
	Args: [], Returns: void
*/
func (o *Control) AcceptEvent() {
	//log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "accept_event")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [Color] with given [code]name[/code] in the [member theme] resource the control uses. If the [code]color[/code] is empty or invalid, the override is cleared and the color from assigned [Theme] is used.
	Args: [{ false name String} { false color Color}], Returns: void
*/
func (o *Control) AddColorOverride(name gdnative.String, color gdnative.Color) {
	//log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromColor(color)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_color_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides an integer constant with given [code]name[/code] in the [member theme] resource the control uses. If the [code]constant[/code] is empty or invalid, the override is cleared and the constant from assigned [Theme] is used.
	Args: [{ false name String} { false constant int}], Returns: void
*/
func (o *Control) AddConstantOverride(name gdnative.String, constant gdnative.Int) {
	//log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromInt(constant)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_constant_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the font with given [code]name[/code] in the [member theme] resource the control uses. If [code]font[/code] is empty or invalid, the override is cleared and the font from assigned [Theme] is used.
	Args: [{ false name String} { false font Font}], Returns: void
*/
func (o *Control) AddFontOverride(name gdnative.String, font FontImplementer) {
	//log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(font.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_font_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the icon with given [code]name[/code] in the [member theme] resource the control uses. If [code]icon[/code] is empty or invalid, the override is cleared and the icon from assigned [Theme] is used.
	Args: [{ false name String} { false texture Texture}], Returns: void
*/
func (o *Control) AddIconOverride(name gdnative.String, texture TextureImplementer) {
	//log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(texture.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_icon_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [Shader] with given [code]name[/code] in the [member theme] resource the control uses. If [code]shader[/code] is empty or invalid, the override is cleared and the shader from assigned [Theme] is used.
	Args: [{ false name String} { false shader Shader}], Returns: void
*/
func (o *Control) AddShaderOverride(name gdnative.String, shader ShaderImplementer) {
	//log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(shader.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_shader_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Overrides the [StyleBox] with given [code]name[/code] in the [member theme] resource the control uses. If [code]stylebox[/code] is empty or invalid, the override is cleared and the [StyleBox] from assigned [Theme] is used.
	Args: [{ false name String} { false stylebox StyleBox}], Returns: void
*/
func (o *Control) AddStyleboxOverride(name gdnative.String, stylebox StyleBoxImplementer) {
	//log.Println("Calling Control.AddStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromObject(stylebox.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "add_stylebox_override")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Godot calls this method to test if [code]data[/code] from a control's [method get_drag_data] can be dropped at [code]position[/code]. [code]position[/code] is local to this control. This method should only be used to test the data. Process the data in [method drop_data]. [codeblock] func can_drop_data(position, data): # Check position if it is relevant to you # Otherwise, just check data return typeof(data) == TYPE_DICTIONARY and data.has("expected") [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: bool
*/
func (o *Control) CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "can_drop_data")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Godot calls this method to pass you the [code]data[/code] from a control's [method get_drag_data] result. Godot first calls [method can_drop_data] to test if [code]data[/code] is allowed to drop at [code]position[/code] where [code]position[/code] is local to this control. [codeblock] func can_drop_data(position, data): return typeof(data) == TYPE_DICTIONARY and data.has("color") func drop_data(position, data): color = data["color"] [/codeblock]
	Args: [{ false position Vector2} { false data Variant}], Returns: void
*/
func (o *Control) DropData(position gdnative.Vector2, data gdnative.Variant) {
	//log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVariant(data)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "drop_data")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forces drag and bypasses [method get_drag_data] and [method set_drag_preview] by passing [code]data[/code] and [code]preview[/code]. Drag will start even if the mouse is neither over nor pressed on this control. The methods [method can_drop_data] and [method drop_data] must be implemented on controls that want to receive drop data.
	Args: [{ false data Variant} { false preview Control}], Returns: void
*/
func (o *Control) ForceDrag(data gdnative.Variant, preview ControlImplementer) {
	//log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVariant(data)
	ptrArguments[1] = gdnative.NewPointerFromObject(preview.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "force_drag")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns the anchor identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetAnchor(margin gdnative.Int) gdnative.Real {
	//log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_anchor")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns [member margin_left] and [member margin_top]. See also [member rect_position].
	Args: [], Returns: Vector2
*/
func (o *Control) GetBegin() gdnative.Vector2 {
	//log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_begin")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns a color from assigned [Theme] with given [code]name[/code] and associated with [Control] of given [code]type[/code]. [codeblock] func _ready(): modulate = get_color("font_color", "Button") #get the color defined for button fonts [/codeblock]
	Args: [{ false name String} { true type String}], Returns: Color
*/
func (o *Control) GetColor(name gdnative.String, aType gdnative.String) gdnative.Color {
	//log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_color")

	// Call the parent method.
	// Color
	retPtr := gdnative.NewEmptyColor()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewColorFromPointer(retPtr)
	return ret
}

/*
        Returns combined minimum size from [member rect_min_size] and [method get_minimum_size].
	Args: [], Returns: Vector2
*/
func (o *Control) GetCombinedMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_combined_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns a constant from assigned [Theme] with given [code]name[/code] and associated with [Control] of given [code]type[/code].
	Args: [{ false name String} { true type String}], Returns: int
*/
func (o *Control) GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int {
	//log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_constant")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
	Args: [{(0, 0) true position Vector2}], Returns: enum.Control::CursorShape
*/
func (o *Control) GetCursorShape(position gdnative.Vector2) ControlCursorShape {
	//log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetCustomMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_custom_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::CursorShape
*/
func (o *Control) GetDefaultCursorShape() ControlCursorShape {
	//log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_default_cursor_shape")

	// Call the parent method.
	// enum.Control::CursorShape
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlCursorShape(ret)
}

/*
        Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns [code]null[/code] if there is no data to drag. Controls that want to receive drop data should implement [method can_drop_data] and [method drop_data]. [code]position[/code] is local to this control. Drag may be forced with [method force_drag]. A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method. [codeblock] func get_drag_data(position): var mydata = make_data() set_drag_preview(make_preview(mydata)) return mydata [/codeblock]
	Args: [{ false position Vector2}], Returns: Variant
*/
func (o *Control) GetDragData(position gdnative.Vector2) gdnative.Variant {
	//log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_drag_data")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Returns [member margin_right] and [member margin_bottom].
	Args: [], Returns: Vector2
*/
func (o *Control) GetEnd() gdnative.Vector2 {
	//log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_end")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::FocusMode
*/
func (o *Control) GetFocusMode() ControlFocusMode {
	//log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_mode")

	// Call the parent method.
	// enum.Control::FocusMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlFocusMode(ret)
}

/*
        Returns the focus neighbour identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] and [member focus_neighbour_top].
	Args: [{ false margin int}], Returns: NodePath
*/
func (o *Control) GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_neighbour")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusNext() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_next")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Returns the control that has the keyboard focus or [code]null[/code] if none.
	Args: [], Returns: Control
*/
func (o *Control) GetFocusOwner() ControlImplementer {
	//log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_owner")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: NodePath
*/
func (o *Control) GetFocusPrevious() gdnative.NodePath {
	//log.Println("Calling Control.GetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_focus_previous")

	// Call the parent method.
	// NodePath
	retPtr := gdnative.NewEmptyNodePath()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewNodePathFromPointer(retPtr)
	return ret
}

/*
        Returns a font from assigned [Theme] with given [code]name[/code] and associated with [Control] of given [code]type[/code].
	Args: [{ false name String} { true type String}], Returns: Font
*/
func (o *Control) GetFont(name gdnative.String, aType gdnative.String) FontImplementer {
	//log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_font")

	// Call the parent method.
	// Font
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newFontFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(FontImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Font" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(FontImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetGlobalPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position and size of the control relative to the top-left corner of the screen. See [member rect_position] and [member rect_size].
	Args: [], Returns: Rect2
*/
func (o *Control) GetGlobalRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_global_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetHGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetHSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_h_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns an icon from assigned [Theme] with given [code]name[/code] and associated with [Control] of given [code]type[/code].
	Args: [{ false name String} { true type String}], Returns: Texture
*/
func (o *Control) GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer {
	//log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_icon")

	// Call the parent method.
	// Texture
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newTextureFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(TextureImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Texture" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(TextureImplementer)
	}

	return &ret
}

/*
        Returns the anchor identified by [code]margin[/code] constant from [enum Margin] enum. A getter method for [member margin_bottom], [member margin_left], [member margin_right] and [member margin_top].
	Args: [{ false margin int}], Returns: float
*/
func (o *Control) GetMargin(margin gdnative.Int) gdnative.Real {
	//log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_margin")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the minimum size for this control. See [member rect_min_size].
	Args: [], Returns: Vector2
*/
func (o *Control) GetMinimumSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_minimum_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::MouseFilter
*/
func (o *Control) GetMouseFilter() ControlMouseFilter {
	//log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_mouse_filter")

	// Call the parent method.
	// enum.Control::MouseFilter
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlMouseFilter(ret)
}

/*
        Returns the width/height occupied in the parent control.
	Args: [], Returns: Vector2
*/
func (o *Control) GetParentAreaSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_area_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the parent control node.
	Args: [], Returns: Control
*/
func (o *Control) GetParentControl() ControlImplementer {
	//log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_parent_control")

	// Call the parent method.
	// Control
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newControlFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ControlImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Control" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ControlImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPivotOffset() gdnative.Vector2 {
	//log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_pivot_offset")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetPosition() gdnative.Vector2 {
	//log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position and size of the control relative to the top-left corner of the parent Control. See [member rect_position] and [member rect_size].
	Args: [], Returns: Rect2
*/
func (o *Control) GetRect() gdnative.Rect2 {
	//log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rect")

	// Call the parent method.
	// Rect2
	retPtr := gdnative.NewEmptyRect2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRect2FromPointer(retPtr)
	return ret
}

/*
        Returns the rotation (in radians).
	Args: [], Returns: float
*/
func (o *Control) GetRotation() gdnative.Real {
	//log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetRotationDegrees() gdnative.Real {
	//log.Println("Calling Control.GetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_rotation_degrees")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetScale() gdnative.Vector2 {
	//log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_scale")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Vector2
*/
func (o *Control) GetSize() gdnative.Vector2 {
	//log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_size")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Control) GetStretchRatio() gdnative.Real {
	//log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stretch_ratio")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns a [StyleBox] from assigned [Theme] with given [code]name[/code] and associated with [Control] of given [code]type[/code].
	Args: [{ false name String} { true type String}], Returns: StyleBox
*/
func (o *Control) GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer {
	//log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_stylebox")

	// Call the parent method.
	// StyleBox
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newStyleBoxFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(StyleBoxImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "StyleBox" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(StyleBoxImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Theme
*/
func (o *Control) GetTheme() ThemeImplementer {
	//log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_theme")

	// Call the parent method.
	// Theme
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newThemeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ThemeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Theme" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ThemeImplementer)
	}

	return &ret
}

/*
        Returns the tooltip, which will appear when the cursor is resting over this control. See [member hint_tooltip].
	Args: [{(0, 0) true at_position Vector2}], Returns: String
*/
func (o *Control) GetTooltip(atPosition gdnative.Vector2) gdnative.String {
	//log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_tooltip")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Control::GrowDirection
*/
func (o *Control) GetVGrowDirection() ControlGrowDirection {
	//log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_grow_direction")

	// Call the parent method.
	// enum.Control::GrowDirection
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ControlGrowDirection(ret)
}

/*
        Undocumented
	Args: [], Returns: int
*/
func (o *Control) GetVSizeFlags() gdnative.Int {
	//log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "get_v_size_flags")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Creates an [InputEventMouseButton] that attempts to click the control. If the event is received, the control acquires focus. [codeblock] func _process(delta): grab_click_focus() #when clicking another Control node, this node will be clicked instead [/codeblock]
	Args: [], Returns: void
*/
func (o *Control) GrabClickFocus() {
	//log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_click_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Steal the focus from another control and become the focused control (see [member focus_mode]).
	Args: [], Returns: void
*/
func (o *Control) GrabFocus() {
	//log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "grab_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns [code]true[/code] if [Color] with given [code]name[/code] and associated with [Control] of given [code]type[/code] exists in assigned [Theme].
	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if [Color] with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasColorOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_color_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if constant with given [code]name[/code] and associated with [Control] of given [code]type[/code] exists in assigned [Theme].
	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if constant with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasConstantOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_constant_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if this is the current focused control. See [member focus_mode].
	Args: [], Returns: bool
*/
func (o *Control) HasFocus() gdnative.Bool {
	//log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_focus")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if font with given [code]name[/code] and associated with [Control] of given [code]type[/code] exists in assigned [Theme].
	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if font with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasFontOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_font_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if icon with given [code]name[/code] and associated with [Control] of given [code]type[/code] exists in assigned [Theme].
	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if icon with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasIconOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_icon_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Virtual method to be implemented by the user. Returns whether the given [code]point[/code] is inside this control. If not overridden, default behavior is checking if the point is within control's Rect. [b]Note:[/b] If you want to check if a point is inside the control, you can use [code]get_rect().has_point(point)[/code].
	Args: [{ false point Vector2}], Returns: bool
*/
func (o *Control) HasPoint(point gdnative.Vector2) gdnative.Bool {
	//log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(point)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_point")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if [Shader] with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasShaderOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasShaderOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_shader_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if [StyleBox] with given [code]name[/code] and associated with [Control] of given [code]type[/code] exists in assigned [Theme].
	Args: [{ false name String} { true type String}], Returns: bool
*/
func (o *Control) HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(name)
	ptrArguments[1] = gdnative.NewPointerFromString(aType)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if [StyleBox] with given [code]name[/code] has a valid override in this [Control] node.
	Args: [{ false name String}], Returns: bool
*/
func (o *Control) HasStyleboxOverride(name gdnative.String) gdnative.Bool {
	//log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "has_stylebox_override")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Control) IsClippingContents() gdnative.Bool {
	//log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "is_clipping_contents")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Invalidates the size cache in this node and in parent nodes up to toplevel. Intended to be used with [method get_minimum_size] when the return value is changed. Setting [member rect_min_size] directly calls this method automatically.
	Args: [], Returns: void
*/
func (o *Control) MinimumSizeChanged() {
	//log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "minimum_size_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Give up the focus. No other control will be able to receive keyboard input.
	Args: [], Returns: void
*/
func (o *Control) ReleaseFocus() {
	//log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "release_focus")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the anchor identified by [code]margin[/code] constant from [enum Margin] enum to value [code]anchor[/code]. A setter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top]. If [code]keep_margin[/code] is [code]true[/code], margins aren't updated after this operation. If [code]push_opposite_anchor[/code] is [code]true[/code] and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If [code]push_opposite_anchor[/code] was [code]false[/code], the left anchor would get value 0.5.
	Args: [{ false margin int} { false anchor float} {False true keep_margin bool} {True true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchor(margin gdnative.Int, anchor gdnative.Real, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)
	ptrArguments[2] = gdnative.NewPointerFromBool(keepMargin)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Works the same as [method set_anchor], but instead of [code]keep_margin[/code] argument and automatic update of margin, it allows to set the margin offset yourself (see [method set_margin]).
	Args: [{ false margin int} { false anchor float} { false offset float} {False true push_opposite_anchor bool}], Returns: void
*/
func (o *Control) SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Real, offset gdnative.Real, pushOppositeAnchor gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(anchor)
	ptrArguments[2] = gdnative.NewPointerFromReal(offset)
	ptrArguments[3] = gdnative.NewPointerFromBool(pushOppositeAnchor)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchor_and_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets both anchor preset and margin preset. See [method set_anchors_preset] and [method set_margins_preset].
	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_and_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the anchors to a [code]preset[/code] from [enum Control.LayoutPreset] enum. This is code equivalent of using the Layout menu in 2D editor. If [code]keep_margins[/code] is [code]true[/code], control's position will also be updated.
	Args: [{ false preset int} {False true keep_margins bool}], Returns: void
*/
func (o *Control) SetAnchorsPreset(preset gdnative.Int, keepMargins gdnative.Bool) {
	//log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargins)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_anchors_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [member margin_left] and [member margin_top] at the same time. Equivalent of changing [member rect_position].
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetBegin(position gdnative.Vector2) {
	//log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_begin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *Control) SetClipContents(enable gdnative.Bool) {
	//log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_clip_contents")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false size Vector2}], Returns: void
*/
func (o *Control) SetCustomMinimumSize(size gdnative.Vector2) {
	//log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_custom_minimum_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false shape int}], Returns: void
*/
func (o *Control) SetDefaultCursorShape(shape gdnative.Int) {
	//log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(shape)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_default_cursor_shape")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Forwards the handling of this control's drag and drop to [code]target[/code] control. Forwarding can be implemented in the target control similar to the methods [method get_drag_data], [method can_drop_data], and [method drop_data] but with two differences: 1. The function name must be suffixed with [b]_fw[/b] 2. The function must take an extra argument that is the control doing the forwarding [codeblock] # ThisControl.gd extends Control func _ready(): set_drag_forwarding(target_control) # TargetControl.gd extends Control func can_drop_data_fw(position, data, from_control): return true func drop_data_fw(position, data, from_control): my_handle_data(data) func get_drag_data_fw(position, from_control): set_drag_preview(my_preview) return my_data() [/codeblock]
	Args: [{ false target Control}], Returns: void
*/
func (o *Control) SetDragForwarding(target ControlImplementer) {
	//log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(target.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_forwarding")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Shows the given control at the mouse pointer. A good time to call this method is in [method get_drag_data]. The control must not be in the scene tree. [codeblock] export (Color, RGBA) var color = Color(1, 0, 0, 1) func get_drag_data(position): # Use a control that is not in the tree var cpb = ColorPickerButton.new() cpb.color = color cpb.rect_size = Vector2(50, 50) set_drag_preview(cpb) return color [/codeblock]
	Args: [{ false control Control}], Returns: void
*/
func (o *Control) SetDragPreview(control ControlImplementer) {
	//log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(control.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_drag_preview")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [member margin_right] and [member margin_bottom] at the same time.
	Args: [{ false position Vector2}], Returns: void
*/
func (o *Control) SetEnd(position gdnative.Vector2) {
	//log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_end")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *Control) SetFocusMode(mode gdnative.Int) {
	//log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the anchor identified by [code]margin[/code] constant from [enum Margin] enum to [Control] at [code]neighbor[/code] node path. A setter method for [member focus_neighbour_bottom], [member focus_neighbour_left], [member focus_neighbour_right] and [member focus_neighbour_top].
	Args: [{ false margin int} { false neighbour NodePath}], Returns: void
*/
func (o *Control) SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromNodePath(neighbour)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_neighbour")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false next NodePath}], Returns: void
*/
func (o *Control) SetFocusNext(next gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusNext()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(next)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_next")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false previous NodePath}], Returns: void
*/
func (o *Control) SetFocusPrevious(previous gdnative.NodePath) {
	//log.Println("Calling Control.SetFocusPrevious()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromNodePath(previous)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_focus_previous")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the [member rect_global_position] to given [code]position[/code]. If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
	Args: [{ false position Vector2} {False true keep_margins bool}], Returns: void
*/
func (o *Control) SetGlobalPosition(position gdnative.Vector2, keepMargins gdnative.Bool) {
	//log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargins)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_global_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetHGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetHSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_h_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the margin identified by [code]margin[/code] constant from [enum Margin] enum to given [code]offset[/code]. A setter method for [member margin_bottom], [member margin_left], [member margin_right] and [member margin_top].
	Args: [{ false margin int} { false offset float}], Returns: void
*/
func (o *Control) SetMargin(margin gdnative.Int, offset gdnative.Real) {
	//log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(margin)
	ptrArguments[1] = gdnative.NewPointerFromReal(offset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the margins to a [code]preset[/code] from [enum Control.LayoutPreset] enum. This is code equivalent of using the Layout menu in 2D editor. Use parameter [code]resize_mode[/code] with constants from [enum Control.LayoutPresetMode] to better determine the resulting size of the [Control]. Constant size will be ignored if used with presets that change size, e.g. [code]PRESET_LEFT_WIDE[/code]. Use parameter [code]margin[/code] to determine the gap between the [Control] and the edges.
	Args: [{ false preset int} {0 true resize_mode int} {0 true margin int}], Returns: void
*/
func (o *Control) SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	//log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(preset)
	ptrArguments[1] = gdnative.NewPointerFromInt(resizeMode)
	ptrArguments[2] = gdnative.NewPointerFromInt(margin)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_margins_preset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false filter int}], Returns: void
*/
func (o *Control) SetMouseFilter(filter gdnative.Int) {
	//log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(filter)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_mouse_filter")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false pivot_offset Vector2}], Returns: void
*/
func (o *Control) SetPivotOffset(pivotOffset gdnative.Vector2) {
	//log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(pivotOffset)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_pivot_offset")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the [member rect_position] to given [code]position[/code]. If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
	Args: [{ false position Vector2} {False true keep_margins bool}], Returns: void
*/
func (o *Control) SetPosition(position gdnative.Vector2, keepMargins gdnative.Bool) {
	//log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargins)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the rotation (in radians).
	Args: [{ false radians float}], Returns: void
*/
func (o *Control) SetRotation(radians gdnative.Real) {
	//log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(radians)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false degrees float}], Returns: void
*/
func (o *Control) SetRotationDegrees(degrees gdnative.Real) {
	//log.Println("Calling Control.SetRotationDegrees()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(degrees)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_rotation_degrees")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false scale Vector2}], Returns: void
*/
func (o *Control) SetScale(scale gdnative.Vector2) {
	//log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(scale)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_scale")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the size (see [member rect_size]). If [code]keep_margins[/code] is [code]true[/code], control's anchors will be updated instead of margins.
	Args: [{ false size Vector2} {False true keep_margins bool}], Returns: void
*/
func (o *Control) SetSize(size gdnative.Vector2, keepMargins gdnative.Bool) {
	//log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromVector2(size)
	ptrArguments[1] = gdnative.NewPointerFromBool(keepMargins)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_size")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false ratio float}], Returns: void
*/
func (o *Control) SetStretchRatio(ratio gdnative.Real) {
	//log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(ratio)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_stretch_ratio")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false theme Theme}], Returns: void
*/
func (o *Control) SetTheme(theme ThemeImplementer) {
	//log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(theme.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_theme")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false tooltip String}], Returns: void
*/
func (o *Control) SetTooltip(tooltip gdnative.String) {
	//log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(tooltip)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_tooltip")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false direction int}], Returns: void
*/
func (o *Control) SetVGrowDirection(direction gdnative.Int) {
	//log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(direction)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_grow_direction")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false flags int}], Returns: void
*/
func (o *Control) SetVSizeFlags(flags gdnative.Int) {
	//log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "set_v_size_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Displays a control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus. If [code]exclusive[/code] is [code]true[/code], other controls will not receive input and clicking outside this control will not close it.
	Args: [{False true exclusive bool}], Returns: void
*/
func (o *Control) ShowModal(exclusive gdnative.Bool) {
	//log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(exclusive)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "show_modal")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Moves the mouse cursor to [code]to_position[/code], relative to [member rect_position] of this [Control].
	Args: [{ false to_position Vector2}], Returns: void
*/
func (o *Control) WarpMouse(toPosition gdnative.Vector2) {
	//log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(toPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Control", "warp_mouse")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// ControlImplementer is an interface that implements the methods
// of the Control class.
type ControlImplementer interface {
	CanvasItemImplementer
	X_ClipsInput() gdnative.Bool
	X_GetMinimumSize() gdnative.Vector2
	X_GetTooltip() gdnative.String
	X_GuiInput(event InputEventImplementer)
	X_MakeCustomTooltip(forText gdnative.String) ObjectImplementer
	X_OverrideChanged()
	X_SetAnchor(margin gdnative.Int, anchor gdnative.Real)
	X_SetGlobalPosition(position gdnative.Vector2)
	X_SetPosition(margin gdnative.Vector2)
	X_SetSize(size gdnative.Vector2)
	X_SizeChanged()
	X_ThemeChanged()
	X_UpdateMinimumSize()
	AcceptEvent()
	AddColorOverride(name gdnative.String, color gdnative.Color)
	AddConstantOverride(name gdnative.String, constant gdnative.Int)
	AddFontOverride(name gdnative.String, font FontImplementer)
	AddIconOverride(name gdnative.String, texture TextureImplementer)
	AddShaderOverride(name gdnative.String, shader ShaderImplementer)
	AddStyleboxOverride(name gdnative.String, stylebox StyleBoxImplementer)
	CanDropData(position gdnative.Vector2, data gdnative.Variant) gdnative.Bool
	DropData(position gdnative.Vector2, data gdnative.Variant)
	ForceDrag(data gdnative.Variant, preview ControlImplementer)
	GetAnchor(margin gdnative.Int) gdnative.Real
	GetBegin() gdnative.Vector2
	GetColor(name gdnative.String, aType gdnative.String) gdnative.Color
	GetCombinedMinimumSize() gdnative.Vector2
	GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int
	GetCustomMinimumSize() gdnative.Vector2
	GetDragData(position gdnative.Vector2) gdnative.Variant
	GetEnd() gdnative.Vector2
	GetFocusNeighbour(margin gdnative.Int) gdnative.NodePath
	GetFocusNext() gdnative.NodePath
	GetFocusOwner() ControlImplementer
	GetFocusPrevious() gdnative.NodePath
	GetFont(name gdnative.String, aType gdnative.String) FontImplementer
	GetGlobalPosition() gdnative.Vector2
	GetGlobalRect() gdnative.Rect2
	GetHSizeFlags() gdnative.Int
	GetIcon(name gdnative.String, aType gdnative.String) TextureImplementer
	GetMargin(margin gdnative.Int) gdnative.Real
	GetMinimumSize() gdnative.Vector2
	GetParentAreaSize() gdnative.Vector2
	GetParentControl() ControlImplementer
	GetPivotOffset() gdnative.Vector2
	GetPosition() gdnative.Vector2
	GetRect() gdnative.Rect2
	GetRotation() gdnative.Real
	GetRotationDegrees() gdnative.Real
	GetScale() gdnative.Vector2
	GetSize() gdnative.Vector2
	GetStretchRatio() gdnative.Real
	GetStylebox(name gdnative.String, aType gdnative.String) StyleBoxImplementer
	GetTheme() ThemeImplementer
	GetTooltip(atPosition gdnative.Vector2) gdnative.String
	GetVSizeFlags() gdnative.Int
	GrabClickFocus()
	GrabFocus()
	HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasColorOverride(name gdnative.String) gdnative.Bool
	HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasConstantOverride(name gdnative.String) gdnative.Bool
	HasFocus() gdnative.Bool
	HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasFontOverride(name gdnative.String) gdnative.Bool
	HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasIconOverride(name gdnative.String) gdnative.Bool
	HasPoint(point gdnative.Vector2) gdnative.Bool
	HasShaderOverride(name gdnative.String) gdnative.Bool
	HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool
	HasStyleboxOverride(name gdnative.String) gdnative.Bool
	IsClippingContents() gdnative.Bool
	MinimumSizeChanged()
	ReleaseFocus()
	SetAnchor(margin gdnative.Int, anchor gdnative.Real, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool)
	SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Real, offset gdnative.Real, pushOppositeAnchor gdnative.Bool)
	SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetAnchorsPreset(preset gdnative.Int, keepMargins gdnative.Bool)
	SetBegin(position gdnative.Vector2)
	SetClipContents(enable gdnative.Bool)
	SetCustomMinimumSize(size gdnative.Vector2)
	SetDefaultCursorShape(shape gdnative.Int)
	SetDragForwarding(target ControlImplementer)
	SetDragPreview(control ControlImplementer)
	SetEnd(position gdnative.Vector2)
	SetFocusMode(mode gdnative.Int)
	SetFocusNeighbour(margin gdnative.Int, neighbour gdnative.NodePath)
	SetFocusNext(next gdnative.NodePath)
	SetFocusPrevious(previous gdnative.NodePath)
	SetGlobalPosition(position gdnative.Vector2, keepMargins gdnative.Bool)
	SetHGrowDirection(direction gdnative.Int)
	SetHSizeFlags(flags gdnative.Int)
	SetMargin(margin gdnative.Int, offset gdnative.Real)
	SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int)
	SetMouseFilter(filter gdnative.Int)
	SetPivotOffset(pivotOffset gdnative.Vector2)
	SetPosition(position gdnative.Vector2, keepMargins gdnative.Bool)
	SetRotation(radians gdnative.Real)
	SetRotationDegrees(degrees gdnative.Real)
	SetScale(scale gdnative.Vector2)
	SetSize(size gdnative.Vector2, keepMargins gdnative.Bool)
	SetStretchRatio(ratio gdnative.Real)
	SetTheme(theme ThemeImplementer)
	SetTooltip(tooltip gdnative.String)
	SetVGrowDirection(direction gdnative.Int)
	SetVSizeFlags(flags gdnative.Int)
	ShowModal(exclusive gdnative.Bool)
	WarpMouse(toPosition gdnative.Vector2)
}
