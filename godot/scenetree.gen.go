package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// SceneTreeGroupCallFlags is an enum for GroupCallFlags values.
type SceneTreeGroupCallFlags int

const (
	SceneTreeGroupCallDefault  SceneTreeGroupCallFlags = 0
	SceneTreeGroupCallRealtime SceneTreeGroupCallFlags = 2
	SceneTreeGroupCallReverse  SceneTreeGroupCallFlags = 1
	SceneTreeGroupCallUnique   SceneTreeGroupCallFlags = 4
)

// SceneTreeStretchAspect is an enum for StretchAspect values.
type SceneTreeStretchAspect int

const (
	SceneTreeStretchAspectExpand     SceneTreeStretchAspect = 4
	SceneTreeStretchAspectIgnore     SceneTreeStretchAspect = 0
	SceneTreeStretchAspectKeep       SceneTreeStretchAspect = 1
	SceneTreeStretchAspectKeepHeight SceneTreeStretchAspect = 3
	SceneTreeStretchAspectKeepWidth  SceneTreeStretchAspect = 2
)

// SceneTreeStretchMode is an enum for StretchMode values.
type SceneTreeStretchMode int

const (
	SceneTreeStretchMode2D       SceneTreeStretchMode = 1
	SceneTreeStretchModeDisabled SceneTreeStretchMode = 0
	SceneTreeStretchModeViewport SceneTreeStretchMode = 2
)

//func NewSceneTreeFromPointer(ptr gdnative.Pointer) SceneTree {
func newSceneTreeFromPointer(ptr gdnative.Pointer) SceneTree {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := SceneTree{}
	obj.SetBaseObject(owner)

	return obj
}

/*
As one of the most important classes, the [code]SceneTree[/code] manages the hierarchy of nodes in a scene as well as scenes themselves. Nodes can be added, retrieved and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded. You can also use the [code]SceneTree[/code] to organize your nodes into groups: every node can be assigned as many groups as you want to create, e.g. a "enemy" group. You can then iterate these groups or even call methods and set properties on all the group's members at once. [code]SceneTree[/code] is the default [MainLoop] implementation used by scenes, and is thus in charge of the game loop.
*/
type SceneTree struct {
	MainLoop
	owner gdnative.Object
}

func (o *SceneTree) BaseClass() string {
	return "SceneTree"
}

/*
        Undocumented
	Args: [{ false arg0 Node}], Returns: void
*/
func (o *SceneTree) X_ChangeScene(arg0 NodeImplementer) {
	//log.Println("Calling SceneTree.X_ChangeScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(arg0.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_change_scene")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ConnectedToServer() {
	//log.Println("Calling SceneTree.X_ConnectedToServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_connected_to_server")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ConnectionFailed() {
	//log.Println("Calling SceneTree.X_ConnectionFailed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_connection_failed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false arg0 int}], Returns: void
*/
func (o *SceneTree) X_NetworkPeerConnected(arg0 gdnative.Int) {
	//log.Println("Calling SceneTree.X_NetworkPeerConnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_network_peer_connected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false arg0 int}], Returns: void
*/
func (o *SceneTree) X_NetworkPeerDisconnected(arg0 gdnative.Int) {
	//log.Println("Calling SceneTree.X_NetworkPeerDisconnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_network_peer_disconnected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: void
*/
func (o *SceneTree) X_ServerDisconnected() {
	//log.Println("Calling SceneTree.X_ServerDisconnected()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "_server_disconnected")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Calls [code]method[/code] on each member of the given group.
	Args: [{ false group String} { false method String}], Returns: Variant
*/
func (o *SceneTree) CallGroup(group gdnative.String, method gdnative.String) gdnative.Variant {
	//log.Println("Calling SceneTree.CallGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "call_group")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Calls [code]method[/code] on each member of the given group, respecting the given [enum GroupCallFlags].
	Args: [{ false flags int} { false group String} { false method String}], Returns: Variant
*/
func (o *SceneTree) CallGroupFlags(flags gdnative.Int, group gdnative.String, method gdnative.String) gdnative.Variant {
	//log.Println("Calling SceneTree.CallGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(flags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromString(method)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "call_group_flags")

	// Call the parent method.
	// Variant
	retPtr := gdnative.NewEmptyVariant()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVariantFromPointer(retPtr)
	return ret
}

/*
        Changes the running scene to the one at the given [code]path[/code], after loading it into a [PackedScene] and creating a new instance. Returns [constant @GlobalScope.OK] on success, [constant @GlobalScope.ERR_CANT_OPEN] if the [code]path[/code] cannot be loaded into a [PackedScene], or [constant @GlobalScope.ERR_CANT_CREATE] if that scene cannot be instantiated.
	Args: [{ false path String}], Returns: enum.Error
*/
func (o *SceneTree) ChangeScene(path gdnative.String) gdnative.Error {
	//log.Println("Calling SceneTree.ChangeScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(path)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "change_scene")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Changes the running scene to a new instance of the given [PackedScene]. Returns [constant @GlobalScope.OK] on success or [constant @GlobalScope.ERR_CANT_CREATE] if the scene cannot be instantiated.
	Args: [{ false packed_scene PackedScene}], Returns: enum.Error
*/
func (o *SceneTree) ChangeSceneTo(packedScene PackedSceneImplementer) gdnative.Error {
	//log.Println("Calling SceneTree.ChangeSceneTo()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(packedScene.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "change_scene_to")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        Returns a [SceneTreeTimer] which will [signal SceneTreeTimer.timeout] after the given time in seconds elapsed in this [code]SceneTree[/code]. If [code]pause_mode_process[/code] is set to [code]false[/code], pausing the [code]SceneTree[/code] will also pause the timer. Commonly used to create a one-shot delay timer as in the following example: [codeblock] func some_function(): print("start") yield(get_tree().create_timer(1.0), "timeout") print("end") [/codeblock]
	Args: [{ false time_sec float} {True true pause_mode_process bool}], Returns: SceneTreeTimer
*/
func (o *SceneTree) CreateTimer(timeSec gdnative.Real, pauseModeProcess gdnative.Bool) SceneTreeTimerImplementer {
	//log.Println("Calling SceneTree.CreateTimer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromReal(timeSec)
	ptrArguments[1] = gdnative.NewPointerFromBool(pauseModeProcess)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "create_timer")

	// Call the parent method.
	// SceneTreeTimer
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newSceneTreeTimerFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(SceneTreeTimerImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "SceneTreeTimer" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(SceneTreeTimerImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Node
*/
func (o *SceneTree) GetCurrentScene() NodeImplementer {
	//log.Println("Calling SceneTree.GetCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_current_scene")

	// Call the parent method.
	// Node
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNodeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NodeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Node" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NodeImplementer)
	}

	return &ret
}

/*
        Undocumented
	Args: [], Returns: Node
*/
func (o *SceneTree) GetEditedSceneRoot() NodeImplementer {
	//log.Println("Calling SceneTree.GetEditedSceneRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_edited_scene_root")

	// Call the parent method.
	// Node
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNodeFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NodeImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Node" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NodeImplementer)
	}

	return &ret
}

/*
        Returns the current frame number, i.e. the total frame count since the application started.
	Args: [], Returns: int
*/
func (o *SceneTree) GetFrame() gdnative.Int {
	//log.Println("Calling SceneTree.GetFrame()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_frame")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: MultiplayerAPI
*/
func (o *SceneTree) GetMultiplayer() MultiplayerAPIImplementer {
	//log.Println("Calling SceneTree.GetMultiplayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_multiplayer")

	// Call the parent method.
	// MultiplayerAPI
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newMultiplayerAPIFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(MultiplayerAPIImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "MultiplayerAPI" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(MultiplayerAPIImplementer)
	}

	return &ret
}

/*
        Returns the peer IDs of all connected peers of this [code]SceneTree[/code]'s [member network_peer].
	Args: [], Returns: PoolIntArray
*/
func (o *SceneTree) GetNetworkConnectedPeers() gdnative.PoolIntArray {
	//log.Println("Calling SceneTree.GetNetworkConnectedPeers()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_connected_peers")

	// Call the parent method.
	// PoolIntArray
	retPtr := gdnative.NewEmptyPoolIntArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolIntArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: NetworkedMultiplayerPeer
*/
func (o *SceneTree) GetNetworkPeer() NetworkedMultiplayerPeerImplementer {
	//log.Println("Calling SceneTree.GetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_peer")

	// Call the parent method.
	// NetworkedMultiplayerPeer
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newNetworkedMultiplayerPeerFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(NetworkedMultiplayerPeerImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "NetworkedMultiplayerPeer" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(NetworkedMultiplayerPeerImplementer)
	}

	return &ret
}

/*
        Returns the unique peer ID of this [code]SceneTree[/code]'s [member network_peer].
	Args: [], Returns: int
*/
func (o *SceneTree) GetNetworkUniqueId() gdnative.Int {
	//log.Println("Calling SceneTree.GetNetworkUniqueId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_network_unique_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the number of nodes in this [code]SceneTree[/code].
	Args: [], Returns: int
*/
func (o *SceneTree) GetNodeCount() gdnative.Int {
	//log.Println("Calling SceneTree.GetNodeCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_node_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns a list of all nodes assigned to the given group.
	Args: [{ false group String}], Returns: Array
*/
func (o *SceneTree) GetNodesInGroup(group gdnative.String) gdnative.Array {
	//log.Println("Calling SceneTree.GetNodesInGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(group)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_nodes_in_group")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: Viewport
*/
func (o *SceneTree) GetRoot() ViewportImplementer {
	//log.Println("Calling SceneTree.GetRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_root")

	// Call the parent method.
	// Viewport
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newViewportFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ViewportImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "Viewport" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ViewportImplementer)
	}

	return &ret
}

/*
        Returns the sender's peer ID for the most recently received RPC call.
	Args: [], Returns: int
*/
func (o *SceneTree) GetRpcSenderId() gdnative.Int {
	//log.Println("Calling SceneTree.GetRpcSenderId()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "get_rpc_sender_id")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the given group exists.
	Args: [{ false name String}], Returns: bool
*/
func (o *SceneTree) HasGroup(name gdnative.String) gdnative.Bool {
	//log.Println("Calling SceneTree.HasGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(name)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "has_group")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if there is a [member network_peer] set.
	Args: [], Returns: bool
*/
func (o *SceneTree) HasNetworkPeer() gdnative.Bool {
	//log.Println("Calling SceneTree.HasNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "has_network_peer")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsDebuggingCollisionsHint() gdnative.Bool {
	//log.Println("Calling SceneTree.IsDebuggingCollisionsHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_debugging_collisions_hint")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsDebuggingNavigationHint() gdnative.Bool {
	//log.Println("Calling SceneTree.IsDebuggingNavigationHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_debugging_navigation_hint")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if the most recent [InputEvent] was marked as handled with [method set_input_as_handled].
	Args: [], Returns: bool
*/
func (o *SceneTree) IsInputHandled() gdnative.Bool {
	//log.Println("Calling SceneTree.IsInputHandled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_input_handled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsMultiplayerPollEnabled() gdnative.Bool {
	//log.Println("Calling SceneTree.IsMultiplayerPollEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_multiplayer_poll_enabled")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns [code]true[/code] if this [code]SceneTree[/code]'s [member network_peer] is in server mode (listening for connections).
	Args: [], Returns: bool
*/
func (o *SceneTree) IsNetworkServer() gdnative.Bool {
	//log.Println("Calling SceneTree.IsNetworkServer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_network_server")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsPaused() gdnative.Bool {
	//log.Println("Calling SceneTree.IsPaused()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_paused")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsRefusingNewNetworkConnections() gdnative.Bool {
	//log.Println("Calling SceneTree.IsRefusingNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_refusing_new_network_connections")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *SceneTree) IsUsingFontOversampling() gdnative.Bool {
	//log.Println("Calling SceneTree.IsUsingFontOversampling()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "is_using_font_oversampling")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Sends the given notification to all members of the [code]group[/code].
	Args: [{ false group String} { false notification int}], Returns: void
*/
func (o *SceneTree) NotifyGroup(group gdnative.String, notification gdnative.Int) {
	//log.Println("Calling SceneTree.NotifyGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromInt(notification)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "notify_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sends the given notification to all members of the [code]group[/code], respecting the given [enum GroupCallFlags].
	Args: [{ false call_flags int} { false group String} { false notification int}], Returns: void
*/
func (o *SceneTree) NotifyGroupFlags(callFlags gdnative.Int, group gdnative.String, notification gdnative.Int) {
	//log.Println("Calling SceneTree.NotifyGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromInt(callFlags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromInt(notification)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "notify_group_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Queues the given object for deletion, delaying the call to [method Object.free] to after the current frame.
	Args: [{ false obj Object}], Returns: void
*/
func (o *SceneTree) QueueDelete(obj ObjectImplementer) {
	//log.Println("Calling SceneTree.QueueDelete()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(obj.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "queue_delete")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Quits the application.
	Args: [], Returns: void
*/
func (o *SceneTree) Quit() {
	//log.Println("Calling SceneTree.Quit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "quit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Reloads the currently active scene. Returns an [enum @GlobalScope.Error] code as described in [method change_scene], with the addition of [constant @GlobalScope.ERR_UNCONFIGURED] if no [member current_scene] was defined yet.
	Args: [], Returns: enum.Error
*/
func (o *SceneTree) ReloadCurrentScene() gdnative.Error {
	//log.Println("Calling SceneTree.ReloadCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "reload_current_scene")

	// Call the parent method.
	// enum.Error
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return gdnative.Error(ret)
}

/*
        If [code]true[/code], the application automatically accepts quitting. Defaults to [code]true[/code].
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetAutoAcceptQuit(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetAutoAcceptQuit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_auto_accept_quit")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false child_node Node}], Returns: void
*/
func (o *SceneTree) SetCurrentScene(childNode NodeImplementer) {
	//log.Println("Calling SceneTree.SetCurrentScene()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(childNode.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_current_scene")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetDebugCollisionsHint(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetDebugCollisionsHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_debug_collisions_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetDebugNavigationHint(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetDebugNavigationHint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_debug_navigation_hint")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false scene Node}], Returns: void
*/
func (o *SceneTree) SetEditedSceneRoot(scene NodeImplementer) {
	//log.Println("Calling SceneTree.SetEditedSceneRoot()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(scene.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_edited_scene_root")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given [code]property[/code] to [code]value[/code] on all members of the given group.
	Args: [{ false group String} { false property String} { false value Variant}], Returns: void
*/
func (o *SceneTree) SetGroup(group gdnative.String, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling SceneTree.SetGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromString(group)
	ptrArguments[1] = gdnative.NewPointerFromString(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the given [code]property[/code] to [code]value[/code] on all members of the given group, respecting the given [enum GroupCallFlags].
	Args: [{ false call_flags int} { false group String} { false property String} { false value Variant}], Returns: void
*/
func (o *SceneTree) SetGroupFlags(callFlags gdnative.Int, group gdnative.String, property gdnative.String, value gdnative.Variant) {
	//log.Println("Calling SceneTree.SetGroupFlags()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(callFlags)
	ptrArguments[1] = gdnative.NewPointerFromString(group)
	ptrArguments[2] = gdnative.NewPointerFromString(property)
	ptrArguments[3] = gdnative.NewPointerFromVariant(value)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_group_flags")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Marks the most recent [InputEvent] as handled.
	Args: [], Returns: void
*/
func (o *SceneTree) SetInputAsHandled() {
	//log.Println("Calling SceneTree.SetInputAsHandled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_input_as_handled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false multiplayer MultiplayerAPI}], Returns: void
*/
func (o *SceneTree) SetMultiplayer(multiplayer MultiplayerAPIImplementer) {
	//log.Println("Calling SceneTree.SetMultiplayer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(multiplayer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_multiplayer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetMultiplayerPollEnabled(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetMultiplayerPollEnabled()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_multiplayer_poll_enabled")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false peer NetworkedMultiplayerPeer}], Returns: void
*/
func (o *SceneTree) SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer) {
	//log.Println("Calling SceneTree.SetNetworkPeer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(peer.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_network_peer")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetPause(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetPause()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_pause")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If [code]true[/code], the application quits automatically on going back (e.g. on Android). Defaults to [code]true[/code].
	Args: [{ false enabled bool}], Returns: void
*/
func (o *SceneTree) SetQuitOnGoBack(enabled gdnative.Bool) {
	//log.Println("Calling SceneTree.SetQuitOnGoBack()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enabled)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_quit_on_go_back")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false refuse bool}], Returns: void
*/
func (o *SceneTree) SetRefuseNewNetworkConnections(refuse gdnative.Bool) {
	//log.Println("Calling SceneTree.SetRefuseNewNetworkConnections()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(refuse)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_refuse_new_network_connections")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Configures screen stretching to the given [enum StretchMode], [enum StretchAspect], minimum size and [code]shrink[/code] ratio.
	Args: [{ false mode int} { false aspect int} { false minsize Vector2} {1 true shrink float}], Returns: void
*/
func (o *SceneTree) SetScreenStretch(mode gdnative.Int, aspect gdnative.Int, minsize gdnative.Vector2, shrink gdnative.Real) {
	//log.Println("Calling SceneTree.SetScreenStretch()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)
	ptrArguments[1] = gdnative.NewPointerFromInt(aspect)
	ptrArguments[2] = gdnative.NewPointerFromVector2(minsize)
	ptrArguments[3] = gdnative.NewPointerFromReal(shrink)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_screen_stretch")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false enable bool}], Returns: void
*/
func (o *SceneTree) SetUseFontOversampling(enable gdnative.Bool) {
	//log.Println("Calling SceneTree.SetUseFontOversampling()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(enable)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SceneTree", "set_use_font_oversampling")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// SceneTreeImplementer is an interface that implements the methods
// of the SceneTree class.
type SceneTreeImplementer interface {
	MainLoopImplementer
	X_ChangeScene(arg0 NodeImplementer)
	X_ConnectedToServer()
	X_ConnectionFailed()
	X_NetworkPeerConnected(arg0 gdnative.Int)
	X_NetworkPeerDisconnected(arg0 gdnative.Int)
	X_ServerDisconnected()
	CallGroup(group gdnative.String, method gdnative.String) gdnative.Variant
	CallGroupFlags(flags gdnative.Int, group gdnative.String, method gdnative.String) gdnative.Variant
	CreateTimer(timeSec gdnative.Real, pauseModeProcess gdnative.Bool) SceneTreeTimerImplementer
	GetCurrentScene() NodeImplementer
	GetEditedSceneRoot() NodeImplementer
	GetFrame() gdnative.Int
	GetMultiplayer() MultiplayerAPIImplementer
	GetNetworkConnectedPeers() gdnative.PoolIntArray
	GetNetworkPeer() NetworkedMultiplayerPeerImplementer
	GetNetworkUniqueId() gdnative.Int
	GetNodeCount() gdnative.Int
	GetNodesInGroup(group gdnative.String) gdnative.Array
	GetRoot() ViewportImplementer
	GetRpcSenderId() gdnative.Int
	HasGroup(name gdnative.String) gdnative.Bool
	HasNetworkPeer() gdnative.Bool
	IsDebuggingCollisionsHint() gdnative.Bool
	IsDebuggingNavigationHint() gdnative.Bool
	IsInputHandled() gdnative.Bool
	IsMultiplayerPollEnabled() gdnative.Bool
	IsNetworkServer() gdnative.Bool
	IsPaused() gdnative.Bool
	IsRefusingNewNetworkConnections() gdnative.Bool
	IsUsingFontOversampling() gdnative.Bool
	NotifyGroup(group gdnative.String, notification gdnative.Int)
	NotifyGroupFlags(callFlags gdnative.Int, group gdnative.String, notification gdnative.Int)
	QueueDelete(obj ObjectImplementer)
	Quit()
	SetAutoAcceptQuit(enabled gdnative.Bool)
	SetCurrentScene(childNode NodeImplementer)
	SetDebugCollisionsHint(enable gdnative.Bool)
	SetDebugNavigationHint(enable gdnative.Bool)
	SetEditedSceneRoot(scene NodeImplementer)
	SetGroup(group gdnative.String, property gdnative.String, value gdnative.Variant)
	SetGroupFlags(callFlags gdnative.Int, group gdnative.String, property gdnative.String, value gdnative.Variant)
	SetInputAsHandled()
	SetMultiplayer(multiplayer MultiplayerAPIImplementer)
	SetMultiplayerPollEnabled(enabled gdnative.Bool)
	SetNetworkPeer(peer NetworkedMultiplayerPeerImplementer)
	SetPause(enable gdnative.Bool)
	SetQuitOnGoBack(enabled gdnative.Bool)
	SetRefuseNewNetworkConnections(refuse gdnative.Bool)
	SetScreenStretch(mode gdnative.Int, aspect gdnative.Int, minsize gdnative.Vector2, shrink gdnative.Real)
	SetUseFontOversampling(enable gdnative.Bool)
}
