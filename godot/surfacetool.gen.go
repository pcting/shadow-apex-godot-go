package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewSurfaceToolFromPointer(ptr gdnative.Pointer) SurfaceTool {
func newSurfaceToolFromPointer(ptr gdnative.Pointer) SurfaceTool {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := SurfaceTool{}
	obj.SetBaseObject(owner)

	return obj
}

/*
The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from a script. All properties except indices need to be added before calling [method add_vertex]. For example, to add vertex colors and UVs: [codeblock] var st = SurfaceTool.new() st.begin(Mesh.PRIMITIVE_TRIANGLES) st.add_color(Color(1, 0, 0)) st.add_uv(Vector2(0, 0)) st.add_vertex(Vector3(0, 0, 0)) [/codeblock] The above [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calling [method add_uv] or [method add_color], then the last values would be used. Vertex attributes must be passed [b]before[/b] calling [method add_vertex]. Failure to do so will result in an error when committing the vertex information to a mesh. Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
*/
type SurfaceTool struct {
	Reference
	owner gdnative.Object
}

func (o *SurfaceTool) BaseClass() string {
	return "SurfaceTool"
}

/*
        Adds an array of bones for the next vertex to use. [code]bones[/code] must contain 4 integers.
	Args: [{ false bones PoolIntArray}], Returns: void
*/
func (o *SurfaceTool) AddBones(bones gdnative.PoolIntArray) {
	//log.Println("Calling SurfaceTool.AddBones()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPoolIntArray(bones)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_bones")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies a [Color] for the next vertex to use.
	Args: [{ false color Color}], Returns: void
*/
func (o *SurfaceTool) AddColor(color gdnative.Color) {
	//log.Println("Calling SurfaceTool.AddColor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromColor(color)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_color")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Adds an index to index array if you are using indexed vertices. Does not need to be called before adding vertices.
	Args: [{ false index int}], Returns: void
*/
func (o *SurfaceTool) AddIndex(index gdnative.Int) {
	//log.Println("Calling SurfaceTool.AddIndex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(index)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_index")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies a normal for the next vertex to use.
	Args: [{ false normal Vector3}], Returns: void
*/
func (o *SurfaceTool) AddNormal(normal gdnative.Vector3) {
	//log.Println("Calling SurfaceTool.AddNormal()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector3(normal)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_normal")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies whether the current vertex (if using only vertex arrays) or current index (if also using index arrays) should use smooth normals for normal calculation.
	Args: [{ false smooth bool}], Returns: void
*/
func (o *SurfaceTool) AddSmoothGroup(smooth gdnative.Bool) {
	//log.Println("Calling SurfaceTool.AddSmoothGroup()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(smooth)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_smooth_group")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies a tangent for the next vertex to use.
	Args: [{ false tangent Plane}], Returns: void
*/
func (o *SurfaceTool) AddTangent(tangent gdnative.Plane) {
	//log.Println("Calling SurfaceTool.AddTangent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPlane(tangent)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_tangent")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Inserts a triangle fan made of array data into [Mesh] being constructed. Requires the primitive type be set to [constant Mesh.PRIMITIVE_TRIANGLES].
	Args: [{ false vertices PoolVector3Array} {[] true uvs PoolVector2Array} {[PoolColorArray] true colors PoolColorArray} {[] true uv2s PoolVector2Array} {[] true normals PoolVector3Array} {[] true tangents Array}], Returns: void
*/
func (o *SurfaceTool) AddTriangleFan(vertices gdnative.PoolVector3Array, uvs gdnative.PoolVector2Array, colors gdnative.PoolColorArray, uv2S gdnative.PoolVector2Array, normals gdnative.PoolVector3Array, tangents gdnative.Array) {
	//log.Println("Calling SurfaceTool.AddTriangleFan()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 6, 6)
	ptrArguments[0] = gdnative.NewPointerFromPoolVector3Array(vertices)
	ptrArguments[1] = gdnative.NewPointerFromPoolVector2Array(uvs)
	ptrArguments[2] = gdnative.NewPointerFromPoolColorArray(colors)
	ptrArguments[3] = gdnative.NewPointerFromPoolVector2Array(uv2S)
	ptrArguments[4] = gdnative.NewPointerFromPoolVector3Array(normals)
	ptrArguments[5] = gdnative.NewPointerFromArray(tangents)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_triangle_fan")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies a set of UV coordinates to use for the next vertex.
	Args: [{ false uv Vector2}], Returns: void
*/
func (o *SurfaceTool) AddUv(uv gdnative.Vector2) {
	//log.Println("Calling SurfaceTool.AddUv()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(uv)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_uv")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies an optional second set of UV coordinates to use for the next vertex.
	Args: [{ false uv2 Vector2}], Returns: void
*/
func (o *SurfaceTool) AddUv2(uv2 gdnative.Vector2) {
	//log.Println("Calling SurfaceTool.AddUv2()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(uv2)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_uv2")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
	Args: [{ false vertex Vector3}], Returns: void
*/
func (o *SurfaceTool) AddVertex(vertex gdnative.Vector3) {
	//log.Println("Calling SurfaceTool.AddVertex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector3(vertex)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_vertex")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Specifies weight values for next vertex to use. [code]weights[/code] must contain 4 values.
	Args: [{ false weights PoolRealArray}], Returns: void
*/
func (o *SurfaceTool) AddWeights(weights gdnative.PoolRealArray) {
	//log.Println("Calling SurfaceTool.AddWeights()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromPoolRealArray(weights)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "add_weights")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Append vertices from a given [Mesh] surface onto the current vertex array with specified [Transform].
	Args: [{ false existing Mesh} { false surface int} { false transform Transform}], Returns: void
*/
func (o *SurfaceTool) AppendFrom(existing MeshImplementer, surface gdnative.Int, transform gdnative.Transform) {
	//log.Println("Calling SurfaceTool.AppendFrom()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(surface)
	ptrArguments[2] = gdnative.NewPointerFromTransform(transform)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "append_from")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Called before adding any vertices. Takes the primitive type as an argument (e.g. [constant Mesh.PRIMITIVE_TRIANGLES]).
	Args: [{ false primitive int}], Returns: void
*/
func (o *SurfaceTool) Begin(primitive gdnative.Int) {
	//log.Println("Calling SurfaceTool.Begin()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(primitive)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "begin")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Clear all information passed into the surface tool so far.
	Args: [], Returns: void
*/
func (o *SurfaceTool) Clear() {
	//log.Println("Calling SurfaceTool.Clear()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "clear")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh]. Default flag is [constant Mesh.ARRAY_COMPRESS_DEFAULT]. See [code]ARRAY_COMPRESS_*[/code] constants in [enum Mesh.ArrayFormat] for other flags.
	Args: [{Null true existing ArrayMesh} {97280 true flags int}], Returns: ArrayMesh
*/
func (o *SurfaceTool) Commit(existing ArrayMeshImplementer, flags gdnative.Int) ArrayMeshImplementer {
	//log.Println("Calling SurfaceTool.Commit()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(flags)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "commit")

	// Call the parent method.
	// ArrayMesh
	retPtr := gdnative.NewEmptyObject()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := newArrayMeshFromPointer(retPtr)

	// Check to see if we already have an instance of this object in our Go instance registry.
	if instance, ok := InstanceRegistry.Get(ret.GetBaseObject().ID()); ok {
		return instance.(ArrayMeshImplementer)
	}

	// Check to see what kind of class this is and create it. This is generally used with
	// GetNode().
	className := ret.GetClass()
	if className != "ArrayMesh" {
		actualRet := getActualClass(className, ret.GetBaseObject())
		return actualRet.(ArrayMeshImplementer)
	}

	return &ret
}

/*

	Args: [], Returns: Array
*/
func (o *SurfaceTool) CommitToArrays() gdnative.Array {
	//log.Println("Calling SurfaceTool.CommitToArrays()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "commit_to_arrays")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	return ret
}

/*
        Creates a vertex array from an existing [Mesh].
	Args: [{ false existing Mesh} { false surface int}], Returns: void
*/
func (o *SurfaceTool) CreateFrom(existing MeshImplementer, surface gdnative.Int) {
	//log.Println("Calling SurfaceTool.CreateFrom()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(surface)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "create_from")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false existing Mesh} { false surface int} { false blend_shape String}], Returns: void
*/
func (o *SurfaceTool) CreateFromBlendShape(existing MeshImplementer, surface gdnative.Int, blendShape gdnative.String) {
	//log.Println("Calling SurfaceTool.CreateFromBlendShape()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(existing.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(surface)
	ptrArguments[2] = gdnative.NewPointerFromString(blendShape)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "create_from_blend_shape")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes the index array by expanding the vertex array.
	Args: [], Returns: void
*/
func (o *SurfaceTool) Deindex() {
	//log.Println("Calling SurfaceTool.Deindex()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "deindex")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Generates normals from vertices so you do not have to do it manually. If [code]flip[/code] is [code]true[/code], the resulting normals will be inverted. Requires the primitive type to be set to [constant Mesh.PRIMITIVE_TRIANGLES].
	Args: [{False true flip bool}], Returns: void
*/
func (o *SurfaceTool) GenerateNormals(flip gdnative.Bool) {
	//log.Println("Calling SurfaceTool.GenerateNormals()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(flip)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "generate_normals")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Generates a tangent vector for each vertex. Requires that each vertex have UVs and normals set already.
	Args: [], Returns: void
*/
func (o *SurfaceTool) GenerateTangents() {
	//log.Println("Calling SurfaceTool.GenerateTangents()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "generate_tangents")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Shrinks the vertex array by creating an index array (avoids reusing vertices).
	Args: [], Returns: void
*/
func (o *SurfaceTool) Index() {
	//log.Println("Calling SurfaceTool.Index()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "index")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets [Material] to be used by the [Mesh] you are constructing.
	Args: [{ false material Material}], Returns: void
*/
func (o *SurfaceTool) SetMaterial(material MaterialImplementer) {
	//log.Println("Calling SurfaceTool.SetMaterial()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(material.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("SurfaceTool", "set_material")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

// SurfaceToolImplementer is an interface that implements the methods
// of the SurfaceTool class.
type SurfaceToolImplementer interface {
	ReferenceImplementer
	AddBones(bones gdnative.PoolIntArray)
	AddColor(color gdnative.Color)
	AddIndex(index gdnative.Int)
	AddNormal(normal gdnative.Vector3)
	AddSmoothGroup(smooth gdnative.Bool)
	AddTangent(tangent gdnative.Plane)
	AddTriangleFan(vertices gdnative.PoolVector3Array, uvs gdnative.PoolVector2Array, colors gdnative.PoolColorArray, uv2S gdnative.PoolVector2Array, normals gdnative.PoolVector3Array, tangents gdnative.Array)
	AddUv(uv gdnative.Vector2)
	AddUv2(uv2 gdnative.Vector2)
	AddVertex(vertex gdnative.Vector3)
	AddWeights(weights gdnative.PoolRealArray)
	AppendFrom(existing MeshImplementer, surface gdnative.Int, transform gdnative.Transform)
	Begin(primitive gdnative.Int)
	Clear()
	Commit(existing ArrayMeshImplementer, flags gdnative.Int) ArrayMeshImplementer
	CommitToArrays() gdnative.Array
	CreateFrom(existing MeshImplementer, surface gdnative.Int)
	CreateFromBlendShape(existing MeshImplementer, surface gdnative.Int, blendShape gdnative.String)
	Deindex()
	GenerateNormals(flip gdnative.Bool)
	GenerateTangents()
	Index()
	SetMaterial(material MaterialImplementer)
}
