package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewCurve2DFromPointer(ptr gdnative.Pointer) Curve2D {
func newCurve2DFromPointer(ptr gdnative.Pointer) Curve2D {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Curve2D{}
	obj.SetBaseObject(owner)

	return obj
}

/*
This class describes a BÃ©zier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes. It keeps a cache of precalculated points along the curve, to speed up further calculations.
*/
type Curve2D struct {
	Resource
	owner gdnative.Object
}

func (o *Curve2D) BaseClass() string {
	return "Curve2D"
}

/*
        Undocumented
	Args: [], Returns: Dictionary
*/
func (o *Curve2D) X_GetData() gdnative.Dictionary {
	//log.Println("Calling Curve2D.X_GetData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "_get_data")

	// Call the parent method.
	// Dictionary
	retPtr := gdnative.NewEmptyDictionary()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewDictionaryFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [{ false arg0 Dictionary}], Returns: void
*/
func (o *Curve2D) X_SetData(arg0 gdnative.Dictionary) {
	//log.Println("Calling Curve2D.X_SetData()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromDictionary(arg0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "_set_data")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Adds a point to a curve at [code]position[/code], with control points [code]in[/code] and [code]out[/code]. If [code]at_position[/code] is given, the point is inserted before the point number [code]at_position[/code], moving that point (and every point after) after the inserted point. If [code]at_position[/code] is not given, or is an illegal value ([code]at_position <0[/code] or [code]at_position >= [method get_point_count][/code]), the point will be appended at the end of the point list.
	Args: [{ false position Vector2} {(0, 0) true in Vector2} {(0, 0) true out Vector2} {-1 true at_position int}], Returns: void
*/
func (o *Curve2D) AddPoint(position gdnative.Vector2, in gdnative.Vector2, out gdnative.Vector2, atPosition gdnative.Int) {
	//log.Println("Calling Curve2D.AddPoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromVector2(position)
	ptrArguments[1] = gdnative.NewPointerFromVector2(in)
	ptrArguments[2] = gdnative.NewPointerFromVector2(out)
	ptrArguments[3] = gdnative.NewPointerFromInt(atPosition)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "add_point")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes all points from the curve.
	Args: [], Returns: void
*/
func (o *Curve2D) ClearPoints() {
	//log.Println("Calling Curve2D.ClearPoints()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "clear_points")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Curve2D) GetBakeInterval() gdnative.Real {
	//log.Println("Calling Curve2D.GetBakeInterval()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_bake_interval")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the total length of the curve, based on the cached points. Given enough density (see [member bake_interval]), it should be approximate enough.
	Args: [], Returns: float
*/
func (o *Curve2D) GetBakedLength() gdnative.Real {
	//log.Println("Calling Curve2D.GetBakedLength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_baked_length")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the cache of points as a [PoolVector2Array].
	Args: [], Returns: PoolVector2Array
*/
func (o *Curve2D) GetBakedPoints() gdnative.PoolVector2Array {
	//log.Println("Calling Curve2D.GetBakedPoints()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_baked_points")

	// Call the parent method.
	// PoolVector2Array
	retPtr := gdnative.NewEmptyPoolVector2Array()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolVector2ArrayFromPointer(retPtr)
	return ret
}

/*
        Returns the closest offset to [code]to_point[/code]. This offset is meant to be used in [method interpolate_baked]. [code]to_point[/code] must be in this curve's local space.
	Args: [{ false to_point Vector2}], Returns: float
*/
func (o *Curve2D) GetClosestOffset(toPoint gdnative.Vector2) gdnative.Real {
	//log.Println("Calling Curve2D.GetClosestOffset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(toPoint)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_closest_offset")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Returns the closest point (in curve's local space) to [code]to_point[/code]. [code]to_point[/code] must be in this curve's local space.
	Args: [{ false to_point Vector2}], Returns: Vector2
*/
func (o *Curve2D) GetClosestPoint(toPoint gdnative.Vector2) gdnative.Vector2 {
	//log.Println("Calling Curve2D.GetClosestPoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(toPoint)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_closest_point")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the number of points describing the curve.
	Args: [], Returns: int
*/
func (o *Curve2D) GetPointCount() gdnative.Int {
	//log.Println("Calling Curve2D.GetPointCount()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_point_count")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return ret
}

/*
        Returns the position of the control point leading to the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
	Args: [{ false idx int}], Returns: Vector2
*/
func (o *Curve2D) GetPointIn(idx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Curve2D.GetPointIn()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_point_in")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position of the control point leading out of the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
	Args: [{ false idx int}], Returns: Vector2
*/
func (o *Curve2D) GetPointOut(idx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Curve2D.GetPointOut()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_point_out")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position of the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
	Args: [{ false idx int}], Returns: Vector2
*/
func (o *Curve2D) GetPointPosition(idx gdnative.Int) gdnative.Vector2 {
	//log.Println("Calling Curve2D.GetPointPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "get_point_position")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position between the vertex [code]idx[/code] and the vertex [code]idx + 1[/code], where [code]t[/code] controls if the point is the first vertex ([code]t = 0.0[/code]), the last vertex ([code]t = 1.0[/code]), or in between. Values of [code]t[/code] outside the range ([code]0.0 >= t <=1[/code]) give strange, but predictable results. If [code]idx[/code] is out of bounds it is truncated to the first or last vertex, and [code]t[/code] is ignored. If the curve has no points, the function sends an error to the console, and returns [code](0, 0)[/code].
	Args: [{ false idx int} { false t float}], Returns: Vector2
*/
func (o *Curve2D) Interpolate(idx gdnative.Int, t gdnative.Real) gdnative.Vector2 {
	//log.Println("Calling Curve2D.Interpolate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromReal(t)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "interpolate")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns a point within the curve at position [code]offset[/code], where [code]offset[/code] is measured as a pixel distance along the curve. To do that, it finds the two cached points where the [code]offset[/code] lies between, then interpolates the values. This interpolation is cubic if [code]cubic[/code] is set to [code]true[/code], or linear if set to [code]false[/code]. Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
	Args: [{ false offset float} {False true cubic bool}], Returns: Vector2
*/
func (o *Curve2D) InterpolateBaked(offset gdnative.Real, cubic gdnative.Bool) gdnative.Vector2 {
	//log.Println("Calling Curve2D.InterpolateBaked()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromReal(offset)
	ptrArguments[1] = gdnative.NewPointerFromBool(cubic)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "interpolate_baked")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Returns the position at the vertex [code]fofs[/code]. It calls [method interpolate] using the integer part of [code]fofs[/code] as [code]idx[/code], and its fractional part as [code]t[/code].
	Args: [{ false fofs float}], Returns: Vector2
*/
func (o *Curve2D) Interpolatef(fofs gdnative.Real) gdnative.Vector2 {
	//log.Println("Calling Curve2D.Interpolatef()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(fofs)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "interpolatef")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	return ret
}

/*
        Deletes the point [code]idx[/code] from the curve. Sends an error to the console if [code]idx[/code] is out of bounds.
	Args: [{ false idx int}], Returns: void
*/
func (o *Curve2D) RemovePoint(idx gdnative.Int) {
	//log.Println("Calling Curve2D.RemovePoint()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "remove_point")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false distance float}], Returns: void
*/
func (o *Curve2D) SetBakeInterval(distance gdnative.Real) {
	//log.Println("Calling Curve2D.SetBakeInterval()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(distance)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "set_bake_interval")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the position of the control point leading to the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console.
	Args: [{ false idx int} { false position Vector2}], Returns: void
*/
func (o *Curve2D) SetPointIn(idx gdnative.Int, position gdnative.Vector2) {
	//log.Println("Calling Curve2D.SetPointIn()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "set_point_in")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the position of the control point leading out of the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console.
	Args: [{ false idx int} { false position Vector2}], Returns: void
*/
func (o *Curve2D) SetPointOut(idx gdnative.Int, position gdnative.Vector2) {
	//log.Println("Calling Curve2D.SetPointOut()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "set_point_out")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the position for the vertex [code]idx[/code]. If the index is out of bounds, the function sends an error to the console.
	Args: [{ false idx int} { false position Vector2}], Returns: void
*/
func (o *Curve2D) SetPointPosition(idx gdnative.Int, position gdnative.Vector2) {
	//log.Println("Calling Curve2D.SetPointPosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(idx)
	ptrArguments[1] = gdnative.NewPointerFromVector2(position)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "set_point_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts. This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough. [code]max_stages[/code] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care! [code]tolerance_degrees[/code] controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
	Args: [{5 true max_stages int} {4 true tolerance_degrees float}], Returns: PoolVector2Array
*/
func (o *Curve2D) Tessellate(maxStages gdnative.Int, toleranceDegrees gdnative.Real) gdnative.PoolVector2Array {
	//log.Println("Calling Curve2D.Tessellate()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(maxStages)
	ptrArguments[1] = gdnative.NewPointerFromReal(toleranceDegrees)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Curve2D", "tessellate")

	// Call the parent method.
	// PoolVector2Array
	retPtr := gdnative.NewEmptyPoolVector2Array()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewPoolVector2ArrayFromPointer(retPtr)
	return ret
}

// Curve2DImplementer is an interface that implements the methods
// of the Curve2D class.
type Curve2DImplementer interface {
	ResourceImplementer
	X_GetData() gdnative.Dictionary
	X_SetData(arg0 gdnative.Dictionary)
	AddPoint(position gdnative.Vector2, in gdnative.Vector2, out gdnative.Vector2, atPosition gdnative.Int)
	ClearPoints()
	GetBakeInterval() gdnative.Real
	GetBakedLength() gdnative.Real
	GetBakedPoints() gdnative.PoolVector2Array
	GetClosestOffset(toPoint gdnative.Vector2) gdnative.Real
	GetClosestPoint(toPoint gdnative.Vector2) gdnative.Vector2
	GetPointCount() gdnative.Int
	GetPointIn(idx gdnative.Int) gdnative.Vector2
	GetPointOut(idx gdnative.Int) gdnative.Vector2
	GetPointPosition(idx gdnative.Int) gdnative.Vector2
	Interpolate(idx gdnative.Int, t gdnative.Real) gdnative.Vector2
	InterpolateBaked(offset gdnative.Real, cubic gdnative.Bool) gdnative.Vector2
	Interpolatef(fofs gdnative.Real) gdnative.Vector2
	RemovePoint(idx gdnative.Int)
	SetBakeInterval(distance gdnative.Real)
	SetPointIn(idx gdnative.Int, position gdnative.Vector2)
	SetPointOut(idx gdnative.Int, position gdnative.Vector2)
	SetPointPosition(idx gdnative.Int, position gdnative.Vector2)
	Tessellate(maxStages gdnative.Int, toleranceDegrees gdnative.Real) gdnative.PoolVector2Array
}
